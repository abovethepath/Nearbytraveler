I see three concrete problems causing what you’re seeing (can’t “join”, member count never updates, messages sometimes don’t send):

Your simple chatroom uses an ad-hoc header x-user-id, but the client never actually sends it on the POST.

There’s no join/leave API in the simple system, so member counts can’t change.

You have two parallel chatroom stacks (old “complex” one and “simple” one) hitting different endpoints. The UI says “joined” from one stack, then tries to open a room using the other stack’s routes → mismatch.

Here’s a small, surgical set of fixes you can paste in to get it working now and keep counts correct.

A) Make the SimpleChatroom actually send the user id
Right now your sendMessageMutation calls apiRequest(...) but doesn’t add the header the server expects.

In client/src/pages/simple-chatroom.tsx, change the mutation to:

ts
Copy
Edit
const sendMessageMutation = useMutation({
  mutationFn: async (content: string) => {
    if (!currentUser?.id) throw new Error("User not found");

    const res = await fetch(`/api/simple-chatrooms/${chatroomId}/messages`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-user-id": String(currentUser.id), // <-- CRITICAL
      },
      credentials: "include",
      body: JSON.stringify({ content: content.trim() }),
    });

    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      throw new Error(err.error || err.message || "Failed to send message");
    }
    return res.json();
  },
  onSuccess: () => {
    setMessageText("");
    queryClient.invalidateQueries({ queryKey: [`/api/simple-chatrooms/${chatroomId}/messages`] });
  },
  onError: (error: any) => {
    toast({ title: "Error", description: error.message, variant: "destructive" });
  }
});
(If your apiRequest helper can take extra headers, you can keep using it—just be sure to pass "x-user-id": currentUser.id.)

B) Add join/leave + member count to the simple API
Right now you only have GET /simple-chatrooms/:id and messages. Add these to server/routes.ts (next to your simple chatroom routes):

ts
Copy
Edit
// Ensure (chatroom_id, user_id) is unique in chatroom_members at the schema level.

app.post('/api/simple-chatrooms/:id/join', async (req, res) => {
  try {
    const chatroomId = parseInt(req.params.id);
    const userId = parseInt(String(req.headers['x-user-id'] || 0));
    if (!chatroomId || !userId) return res.status(400).json({ error: 'Missing chatroomId/userId' });

    // upsert membership
    await db
      .insert(chatroomMembers)
      .values({ chatroomId, userId, role: 'member' })
      .onConflictDoNothing();

    // return fresh count
    const [{ count }] = await db
      .select({ count: sql<number>`count(*)::int` })
      .from(chatroomMembers)
      .where(eq(chatroomMembers.chatroomId, chatroomId));

    res.json({ ok: true, memberCount: count });
  } catch (e) {
    console.error('join error', e);
    res.status(500).json({ error: 'Failed to join' });
  }
});

app.delete('/api/simple-chatrooms/:id/join', async (req, res) => {
  try {
    const chatroomId = parseInt(req.params.id);
    const userId = parseInt(String(req.headers['x-user-id'] || 0));
    if (!chatroomId || !userId) return res.status(400).json({ error: 'Missing chatroomId/userId' });

    await db.delete(chatroomMembers)
      .where(and(eq(chatroomMembers.chatroomId, chatroomId), eq(chatroomMembers.userId, userId)));

    const [{ count }] = await db
      .select({ count: sql<number>`count(*)::int` })
      .from(chatroomMembers)
      .where(eq(chatroomMembers.chatroomId, chatroomId));

    res.json({ ok: true, memberCount: count });
  } catch (e) {
    console.error('leave error', e);
    res.status(500).json({ error: 'Failed to leave' });
  }
});

// For convenience on the room page:
app.get('/api/simple-chatrooms/:id/members/count', async (req, res) => {
  try {
    const chatroomId = parseInt(req.params.id);
    const [{ count }] = await db
      .select({ count: sql<number>`count(*)::int` })
      .from(chatroomMembers)
      .where(eq(chatroomMembers.chatroomId, chatroomId));
    res.json({ memberCount: count });
  } catch (e) {
    res.status(500).json({ error: 'Failed to get member count' });
  }
});
On the client, add simple buttons that hit these endpoints and then refetch the count/messages:

tsx
Copy
Edit
// fetch member count
const { data: memberCountResp } = useQuery<{memberCount:number}>({
  queryKey: [`/api/simple-chatrooms/${chatroomId}/members/count`],
  refetchInterval: 5000,
  enabled: !!chatroomId
});
const memberCount = memberCountResp?.memberCount ?? 0;

async function joinRoom() {
  if (!currentUser?.id) return;
  await fetch(`/api/simple-chatrooms/${chatroomId}/join`, {
    method: "POST",
    headers: { "x-user-id": String(currentUser.id) },
    credentials: "include",
  });
  queryClient.invalidateQueries({ queryKey: [`/api/simple-chatrooms/${chatroomId}/members/count`] });
}

async function leaveRoom() {
  if (!currentUser?.id) return;
  await fetch(`/api/simple-chatrooms/${chatroomId}/join`, {
    method: "DELETE",
    headers: { "x-user-id": String(currentUser.id) },
    credentials: "include",
  });
  queryClient.invalidateQueries({ queryKey: [`/api/simple-chatrooms/${chatroomId}/members/count`] });
}
Render it in your header:

tsx
Copy
Edit
<CardHeader>
  <div className="flex items-center gap-4">
    <Button variant="ghost" size="sm" onClick={() => window.history.back()}>
      <ArrowLeft className="w-4 h-4" />
    </Button>
    <div>
      <CardTitle className="text-xl">{chatroom?.name || `Chatroom ${chatroomId}`}</CardTitle>
      <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
        {chatroom?.city && `${chatroom.city}, ${chatroom.state}`} · {memberCount} online
      </p>
    </div>
    <div className="ml-auto flex gap-2">
      <Button onClick={joinRoom} variant="secondary" size="sm">Join</Button>
      <Button onClick={leaveRoom} variant="outline" size="sm">Leave</Button>
    </div>
  </div>
</CardHeader>
DB tip: add a unique constraint on (chatroom_id, user_id) in chatroom_members so join is idempotent and counts don’t double.

C) Pick one stack and stick to it
Right now you have:

Old endpoints like /api/chatrooms/:id/messages (complex)

New endpoints like /api/simple-chatrooms/:id/messages (simple)

If you’re using the simple page (/simple-chatroom/1), make your “join” buttons and list pages call the simple endpoints too. Don’t mix the old list/join endpoints with the new message endpoints or the UI will say “joined” but the room won’t recognize you.

Quick grep to find stragglers:

bash
Copy
Edit
grep -RIn "/api/chatrooms/" client server --exclude-dir=node_modules
Either delete those old calls or switch them to /api/simple-chatrooms/....

D) Two tiny polish items
In the messages UI, you compare message.sender_id === currentUser?.id. If currentUser.id is a string (from localStorage), coerce once:

ts
Copy
Edit
const currentUserId = Number(currentUser?.id || 0);
...
message.sender_id === currentUserId
Make the queries a little snappier:

ts
Copy
Edit
useQuery(..., { refetchInterval: 2500, refetchOnWindowFocus: false });
TL;DR
Add the x-user-id header from the client when posting messages.

Implement join/leave endpoints for the simple system + a member count endpoint.

Ensure all chatroom UI hits the same (simple) endpoints.

Add a unique index on (chatroom_id, user_id).