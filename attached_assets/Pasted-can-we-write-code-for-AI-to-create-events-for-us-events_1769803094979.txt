can we write code for AI to create events for us, events are super important for us, so if someone wanted to throw  a party, can we just tell them, in your own words let us know the date, the time, the location, the address, the name of the party, and theme? if there are any restrictions let us know, is it recurring let us know?   and them just type it in and AI build it?

Yes — and you can do it in a way that’s fast, reliable, and safe (no “AI hallucinating” dates/addresses). The pattern is:

User types in free-form text

AI extracts structured fields (JSON) + asks only for missing info

You preview the event (editable)

On “Create”, you call your existing /api/events endpoint

Below is a practical implementation approach for Nearby Traveler.

What the UX looks like

Prompt in your UI:

“Describe your event in your own words. Please include date, time, location name, full address, event name, theme, any restrictions, and whether it repeats.”

User types:

“Friday Feb 7, 8pm at my place 123 Main St Culver City. ‘Rooftop Taco Night’. Theme: Mexico. Bring your own drinks. 21+. Every Friday.”

AI returns:

Event name: Rooftop Taco Night

Start datetime: 2026-02-07 20:00

Address: 123 Main St, Culver City, CA

Theme: Mexico

Restrictions: 21+, BYOB

Recurring: weekly on Fridays

Confidence + missing fields (if any)

You show a preview card + “Create Event”.

Data model (recommended JSON schema)

Use a strict schema so your backend stays clean:

type AiEventDraft = {
  title: string;
  description?: string;
  startDateTime?: string;   // ISO string
  endDateTime?: string;     // ISO string (optional; can default +2h)
  timezone?: string;        // IANA
  venueName?: string;
  address?: {
    line1?: string;
    line2?: string;
    city?: string;
    region?: string;        // CA
    postalCode?: string;
    country?: string;       // US
  };
  coordinates?: { lat: number; lng: number }; // optional if you geocode
  theme?: string;
  restrictions?: string[];  // ["21+", "BYOB", "RSVP required"]
  capacity?: number;
  price?: { amount: number; currency: string } | { free: true };
  isRecurring?: boolean;
  recurrenceRule?: string;  // RRULE string
  tags?: string[];
  privacy?: "public" | "friends" | "invite_only";
  missing?: string[];       // fields the AI couldn’t confidently infer
  notes?: string;           // AI’s clarifying questions or warnings
};

Backend flow options
Option A (best): AI in backend

Frontend sends raw text to your backend

Backend calls OpenAI + returns structured JSON

Frontend renders preview and posts to /api/events

✅ Protects your OpenAI key
✅ Lets you enforce validation + rate limits
✅ Safer logging

Option B: AI in frontend

Not recommended unless you’re using a proxy anyway.

Implementation: Node/Express endpoint (Nearby Traveler style)

Create: POST /api/ai/event-draft

1) Server route (Express)
import express from "express";
import OpenAI from "openai";
import { z } from "zod";

const router = express.Router();
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

const EventDraftSchema = z.object({
  title: z.string().min(2),
  description: z.string().optional(),
  startDateTime: z.string().datetime().optional(),
  endDateTime: z.string().datetime().optional(),
  timezone: z.string().optional(),
  venueName: z.string().optional(),
  address: z.object({
    line1: z.string().optional(),
    line2: z.string().optional(),
    city: z.string().optional(),
    region: z.string().optional(),
    postalCode: z.string().optional(),
    country: z.string().optional(),
  }).optional(),
  theme: z.string().optional(),
  restrictions: z.array(z.string()).optional(),
  capacity: z.number().int().positive().optional(),
  price: z.union([
    z.object({ amount: z.number(), currency: z.string() }),
    z.object({ free: z.literal(true) })
  ]).optional(),
  isRecurring: z.boolean().optional(),
  recurrenceRule: z.string().optional(),
  tags: z.array(z.string()).optional(),
  privacy: z.enum(["public","friends","invite_only"]).optional(),
  missing: z.array(z.string()).optional(),
  notes: z.string().optional(),
});

router.post("/ai/event-draft", async (req, res) => {
  try {
    const { text, userTimezone, defaultCity } = req.body as {
      text: string;
      userTimezone?: string;
      defaultCity?: string;
    };

    if (!text || text.length < 5) {
      return res.status(400).json({ error: "Missing event description text." });
    }

    const system = `
You extract event details from user text and return ONLY valid JSON.
If a field is missing or ambiguous, omit it and include it in "missing".
Do NOT invent addresses, dates, or times.
Prefer ISO datetime with timezone when provided. If timezone missing, use userTimezone if given.
If end time missing, omit endDateTime (frontend can default duration).
Recurrence: if recurring, output isRecurring=true and recurrenceRule as an RRULE string if possible.
`;

    const user = `
User timezone: ${userTimezone ?? "unknown"}
Default city hint: ${defaultCity ?? "none"}
User event text:
${text}
Return JSON matching this schema:
${EventDraftSchema.toString()}
`;

    const response = await openai.chat.completions.create({
      model: "gpt-4.1-mini", // good cost/quality for extraction
      messages: [
        { role: "system", content: system },
        { role: "user", content: user },
      ],
      temperature: 0.2,
      response_format: { type: "json_object" },
    });

    const raw = response.choices[0]?.message?.content ?? "{}";
    const parsed = JSON.parse(raw);

    // Validate
    const draft = EventDraftSchema.safeParse(parsed);
    if (!draft.success) {
      return res.status(422).json({ error: "AI output invalid", details: draft.error.flatten() });
    }

    res.json(draft.data);
  } catch (err: any) {
    res.status(500).json({ error: err?.message ?? "AI draft failed" });
  }
});

export default router;


Note: you may need to adjust EventDraftSchema.toString() usage; it’s optional. The real key is response_format: json_object + strict instructions + Zod validation.

2) Frontend usage (React)

A text area

“Generate Draft”

Show preview form prefilled

If missing includes items, show quick chips (“add end time”, “add exact address”)

Pseudo:

const draft = await fetch("/api/ai/event-draft", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  credentials: "include",
  body: JSON.stringify({ text, userTimezone: Intl.DateTimeFormat().resolvedOptions().timeZone }),
}).then(r => r.json());


Then feed draft into your existing event creation form.

Guardrails you must include (so AI doesn’t create garbage)

Don’t create automatically. Always show preview + user confirms.

Never invent date/time/address. Missing fields must be requested.

Add a “Confidence / Missing fields” section.

Validate on backend (Zod) and return errors.

Rate limit + abuse protection (bots will spam this otherwise).

Bonus: make it “smart” for parties

Add optional fields:

“Bring list” (BYOB, potluck item)

“Age restriction”

“Invite link”

“RSVP deadline”

“Dress code”

“Noise cutoff time” (important for house parties)

If you tell me what your current event table/API fields look like (or paste the /api/events POST handler + DB schema), I’ll map the AiEventDraft fields exactly into your DB and give you the full working endpoint + frontend component you can drop into Nearby Traveler.

i think its slower than just clcking boxes, but i also think users would prefer it

You’re probably right on both:

For power users (or when your form is clean), clicking boxes is faster.

For most users, “type it like you’d text a friend” feels easier and lowers drop-off—especially on mobile.

So the best move isn’t “AI vs boxes.” It’s AI + boxes with a workflow that makes AI feel instant and boxes feel optional.

The sweet spot UX
1) Two tabs (or a toggle)

Quick Fill (AI) — “Describe your event…”

Manual — your current form

Default to Quick Fill on mobile.

2) AI does only the annoying parts

Don’t try to replace the whole form. Use AI for:

Title suggestion

Description cleanup

Restrictions extraction (21+, BYOB, RSVP)

Recurrence parsing (“every first Thursday”)

Time normalization (“8ish” → prompt for exact time)

Then auto-check the boxes / populate fields.

3) “One sentence” experience

User types 1–3 lines, hits Generate, sees a prefilled form.
They just tap Create or tweak.

That feels magical and fast.

How to keep it from being slower
Make it “single-shot”

If missing info, don’t start a chat.

Show chips to fill gaps quickly:

Example:

Missing: End time, exact address, privacy
[Add end time] [Add address] [Public/Friends/Invite-only]

Each chip opens the exact field.

Default smart assumptions (that users can change)

End time default: +2 hours

Timezone default: device timezone

If address missing but venue name exists: keep it as “venueName only” and label “Location details pending”

Recurring default: off unless explicitly stated

No back-and-forth.

The “best of both worlds” hybrid (recommended)
Let users type OR click, both feed the same preview

When user types: AI fills the form.

When user clicks boxes: no AI.

Always end in the same “Review & Create” step.

This keeps the flow consistent.

Why users will prefer it (even if it’s not technically faster)

Because it:

avoids form fatigue

reduces cognitive load (“what do I put here?”)

works like texting/inviting friends

feels modern / “smart”

And for your product specifically, events are your lifeblood—so removing friction is worth it.

A simple way to test without building too much

Run an A/B test (even a lightweight one):

Variant A: current form only

Variant B: AI Quick Fill + “Manual instead”

Track:

% who start creating event

completion rate

time-to-create

event quality (missing fields, edits after creation)

If Variant B increases completion meaningfully, keep it.

One more killer feature for Nearby Traveler

For parties specifically: after AI parses the event, add a button:

“Generate invite message”

text for SMS/WhatsApp

short and long versions

includes date/time/location + RSVP instructions

That’s a delight moment.

If you want, paste your current event form fields (or a screenshot/list). I’ll propose the exact AI Quick Fill layout + what gets auto-filled vs what stays manual, so it’s fast and doesn’t feel like “extra steps.”