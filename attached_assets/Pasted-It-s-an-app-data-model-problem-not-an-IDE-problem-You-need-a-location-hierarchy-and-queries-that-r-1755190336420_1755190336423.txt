It’s an app/data-model problem, not an IDE problem. You need a location hierarchy and queries that roll up/down that hierarchy so “Manhattan Beach” users show up in Los Angeles searches—and LA users see events from Santa Monica, Venice, Playa del Rey, etc.

Here’s a clean, practical way to implement it with your stack (React + Node/Express + PostgreSQL/Drizzle). No PostGIS required (you can add it later if you want polygons).

1) Model places with a hierarchy

Create one places table that holds metros, cities, and (optionally) neighborhoods. Each place has a parent_id (its metro or parent city) and a denormalized metro_id (the nearest ancestor whose type='metro').

// drizzle schema (Postgres)
import {
  pgTable, uuid, text, pgEnum, timestamp, doublePrecision, index, uniqueIndex, varchar, boolean
} from "drizzle-orm/pg-core";

export const placeType = pgEnum("place_type", ["metro", "city", "neighborhood"]);

export const places = pgTable("places", {
  id: uuid("id").defaultRandom().primaryKey(),
  name: text("name").notNull(),                  // "Manhattan Beach"
  slug: varchar("slug", { length: 120 }).notNull(), // "manhattan-beach"
  type: placeType("type").notNull(),             // 'city' | 'metro' | 'neighborhood'
  parentId: uuid("parent_id"),                   // -> places.id (nullable for metros)
  metroId: uuid("metro_id").notNull(),           // -> places.id (always set to the ancestor metro id)
  state: varchar("state", { length: 80 }),       // "CA"
  country: varchar("country", { length: 2 }).notNull().default("US"),
  lat: doublePrecision("lat"),
  lon: doublePrecision("lon"),
  // lightweight synonyms so "LA", "L.A.", "Los Ángeles", etc. work
  altNames: text("alt_names").array().default([] as any),
}, (t) => ({
  slugIdx: uniqueIndex("places_slug_uq").on(t.slug),
  nameIdx: index("places_name_idx").on(t.name),
  metroIdx: index("places_metro_idx").on(t.metroId),
  parentIdx: index("places_parent_idx").on(t.parentId),
}));

export const events = pgTable("events", {
  id: uuid("id").defaultRandom().primaryKey(),
  title: text("title").notNull(),
  startsAt: timestamp("starts_at", { withTimezone: true }).notNull(),
  placeId: uuid("place_id").notNull(),  // the specific city/neighborhood id
  metroId: uuid("metro_id").notNull(),  // denormalized: ancestor metro id
  lat: doublePrecision("lat"),
  lon: doublePrecision("lon"),
}, (t) => ({
  metroIdx: index("events_metro_idx").on(t.metroId),
  placeIdx: index("events_place_idx").on(t.placeId),
}));

export const users = pgTable("users", {
  id: uuid("id").defaultRandom().primaryKey(),
  displayName: text("display_name"),
  homePlaceId: uuid("home_place_id").notNull(),  // e.g., Manhattan Beach id
  metroId: uuid("metro_id").notNull(),           // ancestor metro id (e.g., Los Angeles Metro)
  showScopeMetro: boolean("show_scope_metro").notNull().default(true), // user preference
}, (t) => ({
  userMetroIdx: index("users_metro_idx").on(t.metroId),
  userPlaceIdx: index("users_place_idx").on(t.homePlaceId),
}));


Key idea: every event and user stores both their exact place and the ancestor metro_id. That makes queries blazing fast and simple.

2) Populate metro_id automatically

Write one helper to resolve a place’s metro when you insert/update places/events/users.

// server/helpers/places.ts
import { sql } from "drizzle-orm";
import { db } from "../db";

export async function getMetroIdForPlace(placeId: string) {
  const result = await db.execute(sql`
    WITH RECURSIVE ancestors AS (
      SELECT id, parent_id, type FROM places WHERE id = ${placeId}
      UNION ALL
      SELECT p.id, p.parent_id, p.type
      FROM places p
      JOIN ancestors a ON a.parent_id = p.id
    )
    SELECT id FROM ancestors WHERE type = 'metro' LIMIT 1;
  `);
  return (result.rows[0] as any)?.id;
}


Use this any time you:

insert a place (set its metro_id—metros point to themselves),

insert/update a user (set metro_id from their home_place_id),

insert/update an event (set metro_id from its place_id).

3) Query patterns (simple & fast)

A. LA users should see all LA-area events

-- All events in the Los Angeles metro (includes SM, Venice, MB, Culver City, etc.)
SELECT * FROM events
WHERE metro_id = $LA_METRO_ID
ORDER BY starts_at;


B. A Manhattan Beach user wants to be recognized as from MB but still appear in LA searches

Profile shows “Manhattan Beach, CA”.

In LA-wide lists, you include users with users.metro_id = $LA_METRO_ID.

-- Users discoverable in LA metro
SELECT * FROM users WHERE metro_id = $LA_METRO_ID;


C. City-only view (optional filter)

-- Only events in Santa Monica (city-only filter)
SELECT * FROM events WHERE place_id = $SANTA_MONICA_ID;


D. Autocomplete search with synonyms

-- q is normalized lower-case search term like 'venice' or 'l.a.'
SELECT * FROM places
WHERE LOWER(name) LIKE CONCAT('%', $q, '%')
   OR EXISTS (SELECT 1 FROM unnest(alt_names) a WHERE LOWER(a) = LOWER($q))
ORDER BY CASE type WHEN 'metro' THEN 0 WHEN 'city' THEN 1 ELSE 2 END, name
LIMIT 15;

4) Frontend UX (what users feel)

Place picker returns a concrete place_id (e.g., Manhattan Beach) and shows its lineage as a chip: Manhattan Beach • Los Angeles Metro.

Scope toggle on feeds: This city / Metro area (default to Metro).

Discovery pages default to metro scope so LA folks automatically see Santa Monica/Venice/etc.

Profiles display the user’s exact city (not just the metro) so identity feels accurate.

5) Seed LA and children (quick start)

Seed a minimal set now; expand later:

-- Metro
INSERT INTO places (id, name, slug, type, parent_id, metro_id, state, country)
VALUES ('LA_METRO', 'Los Angeles Metro', 'los-angeles-metro', 'metro', NULL, 'LA_METRO', 'CA', 'US');

-- Cities under LA
INSERT INTO places (id, name, slug, type, parent_id, metro_id, state, country, alt_names)
VALUES
('SANTA_MONICA', 'Santa Monica', 'santa-monica', 'city', 'LA_METRO', 'LA_METRO', 'CA', 'US', ARRAY['SM']),
('VENICE', 'Venice', 'venice', 'city', 'LA_METRO', 'LA_METRO', 'CA', 'US', ARRAY['Venice Beach']),
('MANHATTAN_BEACH', 'Manhattan Beach', 'manhattan-beach', 'city', 'LA_METRO', 'LA_METRO', 'CA', 'US', ARRAY['MB']),
('CULVER_CITY', 'Culver City', 'culver-city', 'city', 'LA_METRO', 'LA_METRO', 'CA', 'US', ARRAY['Culver']);


When you later add neighborhoods (e.g., “Marina del Rey” under LA), set parent_id to the appropriate city or directly the metro—both are fine as long as metro_id points to LA_METRO.

6) API endpoints (Express)
// GET /api/events?scope=metro&placeId=<LA_METRO or any child>
app.get("/api/events", async (req, res) => {
  const { scope = "metro", placeId } = req.query as { scope?: "metro"|"city"; placeId: string };
  if (!placeId) return res.status(400).send("placeId required");

  if (scope === "metro") {
    // resolve metro id (if they passed a city)
    const metroId = await getMetroIdForPlace(placeId);
    const rows = await db.execute(sql`SELECT * FROM events WHERE metro_id = ${metroId} ORDER BY starts_at`);
    return res.json(rows.rows);
  } else {
    const rows = await db.execute(sql`SELECT * FROM events WHERE place_id = ${placeId} ORDER BY starts_at`);
    return res.json(rows.rows);
  }
});

// GET /api/users/discover?placeId=<LA or MB>
app.get("/api/users/discover", async (req, res) => {
  const { placeId } = req.query as { placeId: string };
  const metroId = await getMetroIdForPlace(placeId);
  const rows = await db.execute(sql`SELECT * FROM users WHERE metro_id = ${metroId} LIMIT 200`);
  res.json(rows.rows);
});

7) Performance notes

Index events.metro_id, users.metro_id, and places.metro_id (done above).

If you later add geofencing (radius search), add PostGIS; keep the metro logic as your default because it’s predictable for users.

8) What to do in Replit specifically

Replit is just your dev environment. Keep Postgres on Neon, Supabase, or Render (Postgres) and connect from your Replit server.

Add the above migrations and helpers in your Replit project, run the seeds, and switch your feed queries to use metro_id.

If you need boundaries later (e.g., draw LA polygon), enable PostGIS on your hosted Postgres—not inside Replit.

If you want, I can also give you a one-file SQL migration you can paste into your DB to create the tables, indexes, a get_metro_for_place() SQL function, and the LA seed data so you can test immediately.