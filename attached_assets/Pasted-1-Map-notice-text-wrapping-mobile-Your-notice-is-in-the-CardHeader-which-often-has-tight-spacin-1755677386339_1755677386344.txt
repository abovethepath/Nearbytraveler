1) Map notice text wrapping (mobile)

Your notice is in the CardHeader, which often has tight spacing and can inherit overflow styles from the card. Move the notice into CardContent and force proper wrapping. Use whitespace-normal, break-words, and a hard fallback [overflow-wrap:anywhere] so long strings wrap on tiny widths.

2) Map not rendering

Most interactive map libraries need a parent with an explicit height. Even if you pass height="400px" as a prop, if the component doesn’t apply it to a DOM node, you’ll see a blank map. Wrap the map in a relative w-full min-h-[...px] div and let the map fill that. Also guard coordinates with Number.isFinite so bad data doesn’t crash the map render.

Here’s a drop-in version with both fixes:

import { useQuery } from '@tanstack/react-query';
import { InteractiveMap } from './InteractiveMap';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { MapPin } from 'lucide-react';

interface CityMapProps {
  city: string;
  state?: string;
  country: string;
}

interface MapData {
  users: Array<{
    id: number;
    username: string;
    latitude?: number;
    longitude?: number;
    userType: string;
    hometownCity?: string;
    hometownState?: string;
    activeTravelDestination?: string;
  }>;
  events: Array<{
    id: number;
    title: string;
    latitude?: number;
    longitude?: number;
    date: string;
  }>;
  businesses: Array<{
    id: number;
    businessName: string;
    latitude?: number;
    longitude?: number;
    category: string;
  }>;
}

const getCityCoordinates = (city: string, country: string): [number, number] => {
  const cityCoords: Record<string, [number, number]> = {
    'Los Angeles': [34.0522, -118.2437],
    'Playa del Rey': [33.9425, -118.4081],
    'Santa Monica': [34.0195, -118.4912],
    'Venice': [33.9850, -118.4695],
    'Beverly Hills': [34.0736, -118.4004],
    'Hollywood': [34.0928, -118.3287],
    'Culver City': [34.0211, -118.3965],
    'Marina del Rey': [33.9802, -118.4517],
    'Manhattan Beach': [33.8847, -118.4109],
    'New York City': [40.7128, -74.0060],
    'Chicago': [41.8781, -87.6298],
    'Miami': [25.7617, -80.1918],
    'Las Vegas': [36.1699, -115.1398],
    'Nashville': [36.1627, -86.7816],
    'New Orleans': [29.9511, -90.0715],
    'Austin': [30.2672, -97.7431],
    'Boston': [42.3601, -71.0589],
    'Seattle': [47.6062, -122.3321],
    'Denver': [39.7392, -104.9903],
    'Sydney': [-33.8688, 151.2093],
    'London': [51.5074, -0.1278],
    'Paris': [48.8566, 2.3522],
    'Berlin': [52.5200, 13.4050],
    'Tokyo': [35.6762, 139.6503],
    'Barcelona': [41.3851, 2.1734],
    'Amsterdam': [52.3676, 4.9041],
  };

  if (cityCoords[city]) return cityCoords[city];

  const laCities = [
    'Los Angeles','Playa del Rey','Santa Monica','Venice','Beverly Hills','Hollywood',
    'Culver City','Marina del Rey','Manhattan Beach','Hermosa Beach','Redondo Beach',
    'El Segundo','West Hollywood','Pasadena','Burbank','Glendale','Long Beach','Torrance','Inglewood'
  ];
  if (laCities.some(laCity => city.toLowerCase().includes(laCity.toLowerCase()))) {
    return [34.0522, -118.2437];
  }
  return [34.0522, -118.2437];
};

export function CityMap({ city, state, country }: CityMapProps) {
  const { data: mapData, isLoading: isLoadingMapData, error: mapErr } = useQuery<MapData>({
    queryKey: ['/api/city-map-data', city, state, country],
    queryFn: async () => {
      const params = new URLSearchParams();
      params.append('city', city);
      if (state) params.append('state', state);
      params.append('country', country);
      const res = await fetch(`/api/city-map-data?${params}`);
      if (!res.ok) throw new Error('Failed to fetch map data');
      return res.json();
    },
    enabled: !!city && !!country,
    retry: 1,
  });

  const { data: businessMapData, isLoading: isLoadingBusinesses, error: bizErr } = useQuery<Array<{
    id: number;
    name: string;
    username: string;
    city: string;
    state: string;
    country: string;
    currentLatitude: number;
    currentLongitude: number;
    businessType?: string;
    specialty?: string;
    streetAddress?: string;
  }>>({
    queryKey: ['/api/businesses/map', city, state, country],
    queryFn: async () => {
      const params = new URLSearchParams();
      params.append('city', city);
      if (state) params.append('state', state);
      params.append('country', country);
      const res = await fetch(`/api/businesses/map?${params}`);
      if (!res.ok) throw new Error('Failed to fetch business map data');
      return res.json();
    },
    enabled: !!city && !!country,
    retry: 1,
  });

  const isLoading = isLoadingMapData || isLoadingBusinesses;
  const center = getCityCoordinates(city, country);

  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <MapPin className="h-5 w-5" />
            City Overview Map
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-96 bg-gray-100 dark:bg-gray-800 rounded-lg animate-pulse" />
        </CardContent>
      </Card>
    );
  }

  const locations = [
    // users
    ...(mapData?.users ?? [])
      .filter(u => Number.isFinite(Number(u.latitude)) && Number.isFinite(Number(u.longitude)))
      .map(u => ({
        id: u.id,
        lat: Number(u.latitude),
        lng: Number(u.longitude),
        name: `@${u.username}`,
        type: 'user' as const,
        description: u.activeTravelDestination ? `${u.activeTravelDestination}` : `${u.hometownCity || city}`,
      })),
    // events
    ...(mapData?.events ?? [])
      .filter(e => Number.isFinite(Number(e.latitude)) && Number.isFinite(Number(e.longitude)))
      .map(e => ({
        id: e.id + 10000,
        lat: Number(e.latitude),
        lng: Number(e.longitude),
        name: e.title,
        type: 'event' as const,
        description: `Event on ${new Date(e.date).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' })}`,
      })),
    // businesses
    ...(businessMapData ?? [])
      .filter(b => Number.isFinite(Number(b.currentLatitude)) && Number.isFinite(Number(b.currentLongitude)))
      .map(b => ({
        id: b.id + 20000,
        lat: Number(b.currentLatitude),
        lng: Number(b.currentLongitude),
        name: b.name,
        type: 'business' as const,
        description: `${b.businessType || 'Business'}${b.streetAddress ? ` at ${b.streetAddress}` : ` in ${b.city}`}`,
      })),
  ];

  const hasError = mapErr || bizErr;

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <MapPin className="h-5 w-5" />
          {city} Overview Map
        </CardTitle>
      </CardHeader>

      <CardContent className="space-y-4">
        {/* Notice moved here + hard wrapping for tiny screens */}
        <p className="text-xs sm:text-sm text-amber-700 dark:text-amber-300 bg-amber-50 dark:bg-amber-900/20 p-3 rounded-lg border border-amber-200 dark:border-amber-800 whitespace-normal break-words [overflow-wrap:anywhere]">
          <strong className="font-semibold">Map Notice:</strong> Interactive maps are provided for general reference only. Location accuracy and availability may vary. We are not responsible for map functionality or data accuracy.
        </p>

        <div className="flex flex-wrap gap-4 text-sm">
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 bg-blue-500 rounded-full border-2 border-white shadow-sm" />
            <span className="text-gray-600 dark:text-gray-300">Users</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 bg-green-500 rounded-full border-2 border-white shadow-sm" />
            <span className="text-gray-600 dark:text-gray-300">Businesses</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 bg-orange-500 rounded-full border-2 border-white shadow-sm" />
            <span className="text-gray-600 dark:text-gray-300">Events</span>
          </div>
        </div>

        {/* Map needs an explicit height container */}
        <div className="relative w-full min-h-[320px] sm:min-h-[400px] rounded-lg overflow-hidden">
          {/* If your InteractiveMap fills parent, this is enough. If it needs a prop, keep height too. */}
          <InteractiveMap
            key={`${city}-${state ?? ''}-${country}`} // force remount when city changes
            locations={locations}
            center={center}
            zoom={12}
          />
          {(!locations || locations.length === 0) && !hasError && (
            <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-500 dark:text-gray-400 bg-gray-50/60 dark:bg-gray-900/20">
              <MapPin className="h-12 w-12 mb-2 opacity-50" />
              <p>No location data available for {city}</p>
              <p className="text-sm">Users can share their location to appear on the map</p>
            </div>
          )}
          {hasError && (
            <div className="absolute inset-0 flex items-center justify-center text-sm text-red-600 dark:text-red-400 bg-red-50/60 dark:bg-red-900/10">
              Unable to load map data. Please try again.
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}

Notes

Text wrapping: whitespace-normal break-words [overflow-wrap:anywhere] ensures the notice never truncates on narrow phones.

Map height: the wrapper enforces height; most map components will fill this. If your InteractiveMap expects a prop, you can keep height="400px", but make sure it applies it to a DOM element (e.g., <div style={{height}} /> inside).

Safer coordinates: Number.isFinite(Number(val)) guards against null, "", or "NaN".

Errors: now you’ll see a friendly overlay if a fetch failed instead of a blank map.

Re-mount on city change: the key forces a fresh map instance when you switch cities (avoids stale tiles/markers).

If you can share your InteractiveMap component, I’ll wire its internal container to guarantee the height and confirm the props it needs.