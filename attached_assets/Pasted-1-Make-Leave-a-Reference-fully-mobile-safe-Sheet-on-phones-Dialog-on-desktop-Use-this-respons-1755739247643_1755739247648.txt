1) Make “Leave a Reference” fully mobile-safe (Sheet on phones, Dialog on desktop)

Use this responsive wrapper around your reference form so it never renders off-screen and never gets clipped by parent overflow.

// ResponsiveReference.tsx
import { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Sheet, SheetContent, SheetHeader, SheetTitle } from "@/components/ui/sheet";
import { Textarea } from "@/components/ui/textarea";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";

// re-use your QUICK_TAGS_OPTIONS
const TAGS = ["Reliable","Friendly","Knowledgeable","Fun","Safe","Organized","Flexible","Communicative","Respectful","Adventurous","Helpful","Clean","Punctual"];

function useIsSmall() {
  const [small, setSmall] = useState(false);
  useEffect(() => {
    const mq = window.matchMedia("(max-width: 639px)");
    const onChange = () => setSmall(mq.matches);
    onChange(); mq.addEventListener("change", onChange);
    return () => mq.removeEventListener("change", onChange);
  }, []);
  return small;
}

export function LeaveReferenceButton({ revieweeId }: { revieweeId: number }) {
  const [open, setOpen] = useState(false);
  return (
    <>
      <Button size="sm" onClick={() => setOpen(true)}>Leave a Reference</Button>
      <ResponsiveReference open={open} onOpenChange={setOpen} revieweeId={revieweeId} />
    </>
  );
}

export function ResponsiveReference({
  open, onOpenChange, revieweeId
}: {
  open: boolean;
  onOpenChange: (v: boolean) => void;
  revieweeId: number;
}) {
  const isSmall = useIsSmall();
  const qc = useQueryClient();

  const [experience, setExperience] = useState<"positive"|"neutral"|"negative">("positive");
  const [content, setContent] = useState("");
  const [tags, setTags] = useState<string[]>([]);

  useEffect(() => {
    if (open) { setExperience("positive"); setContent(""); setTags([]); }
  }, [open]);

  const toggleTag = (t: string) =>
    setTags((prev) => prev.includes(t) ? prev.filter(x => x !== t) : [...prev, t]);

  const { mutateAsync, isPending } = useMutation({
    mutationFn: async () =>
      apiRequest("POST", "/api/references", {
        revieweeId,
        experience,
        content,
        quickTags: tags,
      }),
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: ["references", revieweeId] });
      onOpenChange(false);
    },
  });

  const Body = (
    <div className="flex flex-col h-full">
      {/* Scrollable content area */}
      <div className="flex-1 overflow-y-auto px-4 sm:px-6 py-4 space-y-4">
        <div>
          <Label className="mb-2 block">How was your experience?</Label>
          <RadioGroup
            className="flex gap-4"
            value={experience}
            onValueChange={(v) => setExperience(v as any)}
          >
            <div className="flex items-center gap-2">
              <RadioGroupItem id="pos" value="positive" /> <Label htmlFor="pos">Positive</Label>
            </div>
            <div className="flex items-center gap-2">
              <RadioGroupItem id="neu" value="neutral" /> <Label htmlFor="neu">Neutral</Label>
            </div>
            <div className="flex items-center gap-2">
              <RadioGroupItem id="neg" value="negative" /> <Label htmlFor="neg">Negative</Label>
            </div>
          </RadioGroup>
        </div>

        <div>
          <Label className="mb-2 block">Quick tags</Label>
          <div className="flex flex-wrap gap-2">
            {TAGS.map((t) => (
              <button
                key={t}
                type="button"
                onClick={() => toggleTag(t)}
                className={`rounded-full text-xs px-3 py-1 border ${tags.includes(t) ? "bg-primary text-primary-foreground" : "bg-transparent"}`}
              >
                {t}
              </button>
            ))}
          </div>
        </div>

        <div>
          <Label className="mb-2 block">Reference</Label>
          <Textarea
            value={content}
            onChange={(e) => setContent(e.target.value)}
            placeholder="What did you do together? What should others know?"
            className="min-h-[140px] resize-y overflow-x-hidden"
          />
        </div>
      </div>

      {/* Sticky footer */}
      <div className="border-t px-4 sm:px-6 py-3 bg-background">
        <div className="flex justify-end gap-2">
          <Button variant="ghost" onClick={() => onOpenChange(false)} disabled={isPending}>Cancel</Button>
          <Button onClick={() => mutateAsync()} disabled={isPending}>Submit</Button>
        </div>
      </div>
    </div>
  );

  if (isSmall) {
    return (
      <Sheet open={open} onOpenChange={onOpenChange}>
        <SheetContent side="bottom" className="h-[90vh] w-full max-w-full p-0 overflow-hidden">
          <SheetHeader className="px-4 sm:px-6 pt-4 pb-0">
            <SheetTitle>Leave a Reference</SheetTitle>
          </SheetHeader>
          {Body}
        </SheetContent>
      </Sheet>
    );
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="w-[min(92vw,720px)] max-h-[90vh] p-0 overflow-hidden">
        <DialogHeader className="px-6 pt-4 pb-0">
          <DialogTitle>Leave a Reference</DialogTitle>
        </DialogHeader>
        {Body}
      </DialogContent>
    </Dialog>
  );
}


Why this fixes it

Uses a Sheet on mobile and a Dialog on desktop (no popover math, no clipping).

The modal container is overflow-hidden; only the inner body scrolls. No nested scrollbars.

Textarea has overflow-x-hidden and grows vertically (resize-y) → no horizontal scrollbar.

Hook this up where your old “Leave Reference” trigger was:

<LeaveReferenceButton revieweeId={user.id} />

2) Kill the site-wide “mystery” scrollbars (once)

These show up when multiple children have overflow-*-scroll or fixed heights. Set a consistent scroll baseline:

A) Global CSS (put in globals.css or equivalent)
/* Prevent accidental horizontal scrolling anywhere */
html, body { overflow-x: hidden; }

/* Use dynamic viewport height to avoid mobile address-bar jump */
:root { --vh: 1vh; }
@supports (height: 100dvh) {
  :root { --vh: 1dvh; }
}

/* Make textareas never show horizontal bars by default */
textarea { overflow-x: hidden; resize: vertical; }

/* Optional: if you must hide tiny inner scrollbars */
.no-scrollbar::-webkit-scrollbar { display: none; }
.no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

B) App shell (choose ONE scroll container)
// In your root layout
export default function AppShell({ children }: { children: React.ReactNode }) {
  return (
    <div className="min-h-[calc(100*var(--vh))] w-full overflow-x-clip">
      {children}
    </div>
  );
}


Do not put overflow-y-auto on both body and your page wrapper. Only the page should scroll.

C) Replace “always show scrollbars” classes

Find these and change:

overflow-y-scroll → overflow-y-auto (only shows when needed)

Any container with max-h-* plus overflow-* around small items (chips, badges, header rows). Remove the overflow or the max-h unless the list is truly long.

Greps to run (and fix):

overflow-y-scroll
overflow-x-auto
max-h-[\d
h-screen


Replace h-screen with min-h-[calc(100*var(--vh))] to avoid mobile browser bars creating phantom scroll.

D) Safe defaults for popovers/combos that still need overlays

If you keep any Popover/DropdownMenu/Select, make them collision-aware so they never render off-screen:

<Popover>
  <PopoverContent
    align="start"
    side="bottom"
    sideOffset={8}
    avoidCollisions
    collisionPadding={12}
    className="w-[min(92vw,380px)]"
  >
    {/* … */}
  </PopoverContent>
</Popover>

3) The tiny vertical bars next to chips/selects

Those are usually caused by a wrapper with overflow-y-auto AND a fixed max-h-*. For all your “pill rows” use:

<div className="flex flex-wrap gap-2 items-center overflow-visible max-w-full">
  {/* <Badge>… */}
</div>


…and make sure the parent does not set overflow-*. If you need a scrollable list, keep the scroll on the list, not the row of chips.

4) Your header grid snippet is fine; just give it a container

Wrap the hero grid in a padding container so nothing touches the viewport edge (which can trigger an x-scroll if a child has a ring/shadow):

<div className="px-4 sm:px-6">
  <div className="grid grid-cols-[auto,1fr] sm:grid-cols-[auto,1fr,auto] gap-4 sm:gap-6">
    {/* avatar / text / actions */}
  </div>
</div>


If you plug in the ResponsiveReference modal and the scroll baseline, your “leave a reference” will stay on screen and the stray scrollbars should disappear. If one stubborn page still shows a bar, paste that component’s wrapper (outermost div/Card and any max-h/overflow classes) and I’ll zero in on the exact lines to remove.