What’s off (quick hits)
userType normalization

Frontend sends: userType: 'currently_traveling'

Backend: if processedData.userType === 'currently_traveling' → sets isCurrentlyTraveling = true and then normalizes userType = 'traveler'.
Impact: anywhere in your app that checks for user.userType === 'currently_traveling' after signup will fail. You should key off:

user.userType === 'traveler' and user.isCurrentlyTraveling === true.

travel destination field name

Frontend builds: currentTripDestination (a display string), plus the separate currentTripDestinationCity/State/Country.

Backend writes: travelDestination from the separate fields (only if currentTripDestinationCity exists).
Impact: If you later read currentTripDestination from the user record, it won’t exist—use travelDestination.

activities/events mapping

Backend will override processedData.activities and processedData.events if it finds localActivities or localEvents.
Frontend sends: activities and events (correct). Just make sure you don’t also send localActivities/localEvents from this flow.

dates as Date objects

You send new Date(formData.dateOfBirth) and new Date(formData.currentTripReturnDate). JSON will serialize to ISO strings—fine—but validate server-side parsing. If your server expects a date-only (no time), consider normalizing to YYYY-MM-DD.

hometown/location strings

You build location and hometown with template strings that assume city/country exist. If the user skips a field, you may end up with things like ", , USA". Add a safe join.

languages / customLanguages

You collect customLanguages in the form but never merge it into languagesSpoken. If users typed custom values, they’ll be dropped unless you parse and merge them before sending.

auth flags & storage duplication

You set both authToken and auth_token, and userData and user. That’s okay if intentional, just be consistent in downstream reads.

Minimal, safe alignment patch

Replace your registrationData build with this (keeps your behavior but aligns names, cleans strings, merges custom languages, and avoids malformed hometown/destination):

// Helpers
const safeJoin = (parts: (string | undefined | null)[]) =>
  parts.filter(Boolean).map(s => String(s).trim()).filter(s => s.length).join(", ");

const parseCustomCSV = (input: string) =>
  input
    ? input.split(",").map(s => s.trim()).filter(Boolean)
    : [];

const dobISO = formData.dateOfBirth ? new Date(formData.dateOfBirth).toISOString() : null;
const returnISO = formData.currentTripReturnDate ? new Date(formData.currentTripReturnDate).toISOString() : null;

// Merge account data from session
const storedAccountData = sessionStorage.getItem("accountData");
let accountData: any = { email: "", password: "", username: "", name: "", phoneNumber: "" };
if (storedAccountData) accountData = JSON.parse(storedAccountData);

// Merge custom languages into languagesSpoken (CSV -> array)
const customLangs = parseCustomCSV(formData.customLanguages);
const languagesSpoken = Array.from(new Set([...(formData.languagesSpoken || []), ...customLangs]));

// Build normalized strings
const hometown = safeJoin([formData.hometownCity, formData.hometownState, formData.hometownCountry]);
const location = hometown; // keep your previous mirror
const travelDestination = safeJoin([
  formData.currentTripDestinationCity,
  formData.currentTripDestinationState,
  formData.currentTripDestinationCountry,
]);

const finalFormData = {
  // server looks for 'currently_traveling' to set flags, then normalizes to 'traveler'
  userType: "currently_traveling",
  isCurrentlyTraveling: true,

  // account
  email: (accountData.email || formData.email || "").toLowerCase().trim(),
  password: accountData.password || formData.password || "",
  username: (accountData.username || formData.username || "").toLowerCase().trim(),
  name: (accountData.name || formData.name || "").trim(),
  phoneNumber: accountData.phoneNumber || "",

  // profile
  dateOfBirth: dobISO,              // ISO string
  bio: formData.bio || "",
  gender: formData.gender || "",
  sexualPreference: formData.sexualPreference || [],

  // hometown/location
  hometownCity: formData.hometownCity || "",
  hometownState: formData.hometownState || "",
  hometownCountry: formData.hometownCountry || "",
  hometown,
  location,

  // current trip (server will derive travelDestination from *fields*, but we also send a normalized string)
  currentTripDestinationCity: formData.currentTripDestinationCity || "",
  currentTripDestinationState: formData.currentTripDestinationState || "",
  currentTripDestinationCountry: formData.currentTripDestinationCountry || "",
  currentTripReturnDate: returnISO, // ISO string
  // Optional: send a display field; backend ignores it, but harmless:
  currentTripDestination: travelDestination,

  // server uses activities/events unless localActivities/localEvents are present
  activities: formData.activities || [],
  events: formData.events || [],

  // languages
  languagesSpoken,

  // flags
  isVeteran: !!formData.isVeteran,
  isActiveDuty: !!formData.isActiveDuty,
  travelingWithChildren: !!formData.travelingWithChildren,
};


And the fetch:

const response = await fetch("/api/register", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify(finalFormData),
});

Guardrails to add (pre-submit)

Requireds: ensure email, password, username, name, dateOfBirth pass your validateDateInput / getDateInputConstraints(), and validateCustomInput for custom interests/activities/events (you imported those utils but aren’t using them here).

Arrays: run validateSelections on interests, activities, events, languagesSpoken before posting.

No locals fields: for this flow, do not include localActivities or localEvents in the payload.

Downstream code changes to avoid surprises

Wherever you check the role, update to:

const isTraveler = user.userType === "traveler";
const isCurrentlyTraveling = !!user.isCurrentlyTraveling;
// previously checked for 'currently_traveling'—don’t.


When displaying destination, read user.travelDestination (not currentTripDestination).

If you want, paste your server’s /api/register handler (around parsing/validation) and I’ll sanity-check date parsing and any coercions so DOB and return dates land correctly.

You said:
they no longer ask anything at sign up except, on page one, name, username, password, email, phone number... on page two, date of birth, hometown, if traveling where and when it end and chose from a list of 30 top choices (min chose 3), we removed all other questions
ChatGPT said:
Thought for 10s

Perfect—that makes this a lot cleaner. Here’s how I’d tighten your signup flow and payload to match the two-page form and the backend mapper you showed.

What the new payload should look like

Only send what you now collect:

type RegisterPayload = {
  // page 1
  userType: "currently_traveling";      // backend will normalize to 'traveler'
  isCurrentlyTraveling: boolean;        // true if they’re traveling now
  email: string;
  password: string;
  username: string;
  name: string;
  phoneNumber?: string;

  // page 2
  dateOfBirth: string;                  // ISO date-only 'YYYY-MM-DD'
  hometownCity: string;
  hometownState?: string;
  hometownCountry: string;
  hometown: string;                     // "City, State, Country" (safe-joined)
  location: string;                     // mirror of hometown

  // traveling (optional if not traveling)
  currentTripDestinationCity?: string;
  currentTripDestinationState?: string;
  currentTripDestinationCountry?: string;
  currentTripReturnDate?: string;       // ISO date-only 'YYYY-MM-DD'

  // top choices (min 3)
  interests: string[];                  // chosen from your 30-item list
};


The backend block you pasted will then:

set isCurrentlyTraveling = true when userType === 'currently_traveling'

normalize userType = 'traveler'

derive and store travelDestination from the currentTripDestination* fields

Minimal client changes (drop the old fields + sanitize)

Replace your formData to only what you now ask:

const [formData, setFormData] = useState({
  // page 1
  name: "",
  username: "",
  email: "",
  password: "",
  phoneNumber: "",

  // page 2
  dateOfBirth: "", // 'YYYY-MM-DD'
  hometownCity: "",
  hometownState: "",
  hometownCountry: "",

  // travel (optional)
  isCurrentlyTraveling: true, // set based on the flow; if this is the “traveling” signup, keep true
  currentTripDestinationCity: "",
  currentTripDestinationState: "",
  currentTripDestinationCountry: "",
  currentTripReturnDate: "", // 'YYYY-MM-DD'

  // top choices
  interests: [] as string[],
});

Safe helpers
const safeJoin = (parts: Array<string | undefined | null>) =>
  parts.filter(Boolean).map(s => s!.trim()).filter(Boolean).join(", ");

const toDateOnlyISO = (value: string) => {
  // expect 'YYYY-MM-DD' from <input type="date">
  // trust browser to validate; still trim
  return value ? value.trim() : "";
};

Build the exact payload you need now
const storedAccountData = sessionStorage.getItem("accountData");
let accountData: any = { email: "", password: "", username: "", name: "", phoneNumber: "" };
if (storedAccountData) accountData = JSON.parse(storedAccountData);

// normalized strings
const hometown = safeJoin([formData.hometownCity, formData.hometownState, formData.hometownCountry]);
const location = hometown;

const payload: RegisterPayload = {
  userType: "currently_traveling",
  isCurrentlyTraveling: true, // this flow is specifically for traveling signups
  email: (accountData.email || formData.email || "").toLowerCase().trim(),
  password: (accountData.password || formData.password || "").trim(),
  username: (accountData.username || formData.username || "").toLowerCase().trim(),
  name: (accountData.name || formData.name || "").trim(),
  phoneNumber: (accountData.phoneNumber || "").trim(),

  dateOfBirth: toDateOnlyISO(formData.dateOfBirth),
  hometownCity: formData.hometownCity.trim(),
  hometownState: formData.hometownState?.trim() || "",
  hometownCountry: formData.hometownCountry.trim(),
  hometown,
  location,

  // travel only if provided (backend will build travelDestination from these)
  currentTripDestinationCity: formData.currentTripDestinationCity?.trim() || "",
  currentTripDestinationState: formData.currentTripDestinationState?.trim() || "",
  currentTripDestinationCountry: formData.currentTripDestinationCountry?.trim() || "",
  currentTripReturnDate: toDateOnlyISO(formData.currentTripReturnDate),

  // top choices (require at least 3)
  interests: formData.interests,
};

Submit and auth handling
const response = await fetch("/api/register", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify(payload),
});
const data = await response.json();

if (response.ok && data.user) {
  if (data.token) {
    localStorage.setItem("auth_token", data.token); // pick one key & stick to it
  }
  localStorage.setItem("user", JSON.stringify(data.user));
  authStorage.setUser(data.user);
  setUser(data.user);
  login(data.user, data.token);
  sessionStorage.removeItem("accountData");
  setLocation("/welcome");
} else {
  toast({ title: "Registration failed", description: data.message || "Something went wrong.", variant: "destructive" });
}

Simple client-side validation (keep it strict + short)

Page 1 (all required): name, username, email, password

Page 2 (all required): dateOfBirth, hometownCity, hometownCountry, interests (≥3)

Travel fields: required only if isCurrentlyTraveling === true and you showed the traveling step.

Quick check right before POST:

const errors: string[] = [];

if (!payload.name) errors.push("Name is required.");
if (!payload.username) errors.push("Username is required.");
if (!payload.email) errors.push("Email is required.");
if (!payload.password) errors.push("Password is required.");
if (!payload.dateOfBirth) errors.push("Date of birth is required.");
if (!payload.hometownCity || !payload.hometownCountry) errors.push("Hometown city and country are required.");

if ((payload.interests?.length ?? 0) < 3) errors.push("Please choose at least 3 interests.");

if (payload.isCurrentlyTraveling) {
  if (!payload.currentTripDestinationCity || !payload.currentTripDestinationCountry) {
    errors.push("Please add your current trip destination city and country.");
  }
  if (!payload.currentTripReturnDate) errors.push("Please add your trip end date.");
}

if (errors.length) {
  toast({ title: "Check the form", description: errors.join(" "), variant: "destructive" });
  return;
}

Clean up imports

Since you dropped a bunch of questions, remove these unused imports to keep the bundle lean:

getAllActivities, getAllEvents, getAllLanguages, validateCustomInput, filterCustomEntries, GENDER_OPTIONS, SEXUAL_PREFERENCE_OPTIONS, PRIVACY_NOTES, anything not referenced.

Keep getAllInterests (for your 30-item list) and validateSelections (to enforce ≥3 if you already use it).

Downstream expectations

After signup, the user object will be { userType: 'traveler', isCurrentlyTraveling: true|false, travelDestination?: string }.

Wherever you show “destination,” read travelDestination.

Don’t check for userType === 'currently_traveling' anywhere post-register; use user.userType === 'traveler' plus the flag.

If you want, paste your current SignupTraveling component (just the parts you edited), and I’ll inline the exact diffs to make it copy-pasteable.

You said:
we have special location drop downs, consistent site wide, i want to make sure those are not lost... they are specific to the site with Los Angeles heavy focusued
ChatGPT said:
Thought for 12s

Gotcha—let’s keep your site-specific location dropdowns (LA-focused) as the single source of truth and wire them cleanly into the new two-page signup so nothing gets lost.

Here’s a drop-in approach:

1) Keep one canonical shape for locations

Use { city, state, country } everywhere (hometown + destination). Normalize from your dropdown’s selected option into those three strings.

export type SimpleLocation = {
  city: string;
  state?: string;     // optional for non-US
  country: string;
};

2) A tiny normalizer (from your dropdown value → 3 fields)

Most location pickers return a rich object. Map it to your 3 fields so your backend always receives exactly what it expects.

// utils/location.ts
export const normalizeLocation = (loc: any): SimpleLocation => {
  // Adjust based on YOUR SmartLocationInput shape
  // Examples of possible fields: loc.cityName, loc.admin1, loc.countryName, loc.iso2, etc.
  return {
    city: (loc?.city || loc?.cityName || "").trim(),
    state: (loc?.state || loc?.admin1 || "").trim() || undefined,
    country: (loc?.country || loc?.countryName || "").trim(),
  };
};

export const safeJoinLocation = (l: SimpleLocation) =>
  [l.city, l.state, l.country].filter(Boolean).join(", ");

3) Wrap your site-wide dropdown in a tiny adapter

Use your existing SmartLocationInput (LA-heavy suggestions, neighborhoods, etc.). Keep all its magic, just standardize the output.

// components/LocationFieldGroup.tsx
import { SmartLocationInput } from "@/components/SmartLocationInput";
import { Label } from "@/components/ui/label";
import { normalizeLocation, safeJoinLocation } from "@/lib/utils/location";
import type { SimpleLocation } from "@/lib/utils/location";

type Props = {
  id: string;
  label: string;
  value: SimpleLocation;
  onChange: (loc: SimpleLocation) => void;
  required?: boolean;
  placeholder?: string;
  // If your SmartLocationInput supports LA-first mode, pass a prop to bias results
  laFirst?: boolean;
};

export default function LocationFieldGroup({
  id, label, value, onChange, required, placeholder, laFirst = true,
}: Props) {
  return (
    <div className="space-y-2">
      <Label htmlFor={id}>{label}</Label>
      <SmartLocationInput
        id={id}
        placeholder={placeholder ?? "Start typing a city…"}
        laFirst={laFirst}              // keeps your LA-focused behavior
        value={safeJoinLocation(value)}// show "City, State, Country"
        onSelect={(raw: any) => {
          const norm = normalizeLocation(raw);
          onChange(norm);
        }}
        // Optional: allow free text, but still normalize on blur/confirm
        onManualEntry={(raw: string) => {
          // Basic split; your component might already do richer parsing
          const parts = raw.split(",").map(s => s.trim());
          const [city, state, country] = [parts[0] || "", parts[1] || "", parts[2] || ""];
          onChange({ city, state: state || undefined, country });
        }}
        // You can pass any additional props your component needs,
        // like country restrictions, LA neighborhood boosts, etc.
      />
    </div>
  );
}

4) Use it in SignupTraveling for both Hometown and Destination

This keeps the LA-biased dropdown intact and guarantees the backend receives city/state/country strings.

// in SignupTraveling
const [formData, setFormData] = useState({
  // page 1
  name: "", username: "", email: "", password: "", phoneNumber: "",

  // page 2
  dateOfBirth: "",

  hometownCity: "", hometownState: "", hometownCountry: "",
  // traveling
  isCurrentlyTraveling: true,
  currentTripDestinationCity: "",
  currentTripDestinationState: "",
  currentTripDestinationCountry: "",
  currentTripReturnDate: "",

  interests: [] as string[],
});

// local view state to feed the component (optional)
const [hometown, setHometown] = useState<SimpleLocation>({ city: "", state: "", country: "" });
const [destination, setDestination] = useState<SimpleLocation>({ city: "", state: "", country: "" });

// When location changes, mirror into formData
const applyHometown = (loc: SimpleLocation) => {
  setHometown(loc);
  setFormData(fd => ({
    ...fd,
    hometownCity: loc.city,
    hometownState: loc.state ?? "",
    hometownCountry: loc.country,
  }));
};

const applyDestination = (loc: SimpleLocation) => {
  setDestination(loc);
  setFormData(fd => ({
    ...fd,
    currentTripDestinationCity: loc.city,
    currentTripDestinationState: loc.state ?? "",
    currentTripDestinationCountry: loc.country,
  }));
};


Render:

{/* Hometown (LA-first suggestions preserved by SmartLocationInput) */}
<LocationFieldGroup
  id="hometown"
  label="Hometown"
  value={hometown}
  onChange={applyHometown}
  required
  laFirst
/>

{/* Destination (only if traveling) */}
{formData.isCurrentlyTraveling && (
  <>
    <LocationFieldGroup
      id="destination"
      label="Current Trip Destination"
      value={destination}
      onChange={applyDestination}
      required
      laFirst
    />
    {/* trip end date input here */}
  </>
)}

5) Build the payload (unchanged backend contract)

Keep the same payload keys the server expects, but now they’re guaranteed to come from your LA-biased component:

const hometownStr = safeJoinLocation({
  city: formData.hometownCity,
  state: formData.hometownState || undefined,
  country: formData.hometownCountry,
});

const travelDestinationStr = safeJoinLocation({
  city: formData.currentTripDestinationCity,
  state: formData.currentTripDestinationState || undefined,
  country: formData.currentTripDestinationCountry,
});

const payload = {
  userType: "currently_traveling",
  isCurrentlyTraveling: formData.isCurrentlyTraveling,

  email: formData.email.toLowerCase().trim(),
  password: formData.password,
  username: formData.username.toLowerCase().trim(),
  name: formData.name.trim(),
  phoneNumber: formData.phoneNumber?.trim() || "",

  dateOfBirth: formData.dateOfBirth, // 'YYYY-MM-DD'

  hometownCity: formData.hometownCity,
  hometownState: formData.hometownState,
  hometownCountry: formData.hometownCountry,
  hometown: hometownStr,
  location: hometownStr,

  currentTripDestinationCity: formData.currentTripDestinationCity,
  currentTripDestinationState: formData.currentTripDestinationState,
  currentTripDestinationCountry: formData.currentTripDestinationCountry,
  currentTripReturnDate: formData.currentTripReturnDate, // 'YYYY-MM-DD'

  interests: formData.interests,
  // Optional display-only field; backend derives its own travelDestination anyway:
  currentTripDestination: travelDestinationStr,
};

6) A couple of LA-specific niceties (optional but recommended)

Neighborhoods & suburbs: If your SmartLocationInput supports layers, prioritize LA city + popular neighborhoods (Venice, Silver Lake, Santa Monica, Hollywood, DTLA) and fold them up to city = Los Angeles and state = CA, country = USA if you want a canonical record. If you do want neighborhood-level granularity, add a separate neighborhood field in the picker, but don’t send it to the backend unless the DB supports it.

US/Non-US logic: If country !== "United States", hide the state region in the UI and store it as undefined.

Consistency: Anywhere else in the app that asks for a location (search, events, profiles), use this same LocationFieldGroup wrapper so the LA-first behavior and normalization are consistent site-wide.

If you share the current prop signature of SmartLocationInput (what it emits on onSelect), I’ll tailor the normalizeLocation function to match it exactly so you can paste it in without guessing.

You said:
issue is they are all saved as sprcific city and Los Angeles Metropolitan and i dont want to lose that logic
ChatGPT said:
Thought for 9s

Totally—keep the “specific city” vs “Los Angeles Metropolitan” logic intact. The trick is to preserve scope (city vs metro) alongside the normalized city/state/country so your backend keeps working, while your app logic still knows when the user picked the metro.

Here’s a clean, drop-in pattern.

1) Add a tiny, stable schema for scope
// lib/locationTypes.ts
export type LocationScope = "city" | "metro";

export type SimpleLocation = {
  city: string;           // "" when scope === "metro"
  state?: string;         // optional for non-US
  country: string;
};

export type MetroMeta = {
  metroCode?: string;     // e.g. CBSA "31180"
  metroName?: string;     // e.g. "Los Angeles–Long Beach–Anaheim, CA"
};

export type LocationSelection = {
  scope: LocationScope;   // "city" OR "metro"
  location: SimpleLocation;
  metro?: MetroMeta;      // present when scope === "metro"
};

2) Normalize the picker output without losing scope

Have your SmartLocationInput emit { scope, location, metro }. Your adapter preserves both, and also prepares the legacy fields your backend expects.

// lib/locationNormalize.ts
import type { LocationSelection, SimpleLocation } from "./locationTypes";

export const safeJoinLocation = (l: SimpleLocation) =>
  [l.city, l.state, l.country].filter(Boolean).join(", ");

export const normalizeFromPicker = (raw: any): LocationSelection => {
  // Match YOUR SmartLocationInput shape here.
  // Examples:
  // - City choice: { type: 'city', city: 'Santa Monica', admin1: 'CA', country: 'United States' }
  // - Metro choice: { type: 'metro', metroCode: '31180', metroName: 'Los Angeles–Long Beach–Anaheim, CA', admin1: 'CA', country: 'United States' }

  if (raw?.type === "metro") {
    return {
      scope: "metro",
      location: {
        city: "",                                 // no single city for metro
        state: raw.admin1 || "CA",
        country: raw.country || "United States",
      },
      metro: {
        metroCode: raw.metroCode || "31180",
        metroName: raw.metroName || "Los Angeles–Long Beach–Anaheim, CA",
      },
    };
  }

  // default to city
  return {
    scope: "city",
    location: {
      city: (raw.city || raw.cityName || "").trim(),
      state: (raw.admin1 || raw.state || "").trim() || undefined,
      country: (raw.country || raw.countryName || "").trim(),
    },
  };
};

3) Wrap your dropdown so every form uses the same contract
// components/LocationField.tsx
import { SmartLocationInput } from "@/components/SmartLocationInput";
import { normalizeFromPicker, safeJoinLocation } from "@/lib/locationNormalize";
import type { LocationSelection } from "@/lib/locationTypes";

export function LocationField({
  id, label, value, onChange, required, laFirst = true,
}: {
  id: string;
  label: string;
  value: LocationSelection;
  onChange: (v: LocationSelection) => void;
  required?: boolean;
  laFirst?: boolean;
}) {
  const display = value.scope === "city"
    ? safeJoinLocation(value.location)
    : value.metro?.metroName || safeJoinLocation(value.location);

  return (
    <div className="space-y-2">
      <label htmlFor={id} className="text-sm font-medium">{label}</label>
      <SmartLocationInput
        id={id}
        laFirst={laFirst}             // keeps your LA-bias
        value={display}
        onSelect={(raw: any) => onChange(normalizeFromPicker(raw))}
      />
      {/* Optional: a tiny badge so users see they picked the metro */}
      {value.scope === "metro" && (
        <div className="text-xs text-muted-foreground">
          Area: {value.metro?.metroName} (Metro)
        </div>
      )}
    </div>
  );
}

4) Store both: legacy fields (for backend) + scope fields (for your logic)

Your backend mapping expects ...City/State/Country and builds travelDestination. We’ll send those plus scope metadata (ignored by backend if not used).

// in SignupTraveling component
const [hometownSel, setHometownSel] = useState<LocationSelection>({
  scope: "city",
  location: { city: "", state: "", country: "" },
});
const [destSel, setDestSel] = useState<LocationSelection>({
  scope: "city",
  location: { city: "", state: "", country: "" },
});

// Build payload (ONLY required + legacy fields, plus safe extras)
const payload = {
  userType: "currently_traveling",
  isCurrentlyTraveling: formData.isCurrentlyTraveling,

  email: formData.email.toLowerCase().trim(),
  password: formData.password,
  username: formData.username.toLowerCase().trim(),
  name: formData.name.trim(),
  phoneNumber: formData.phoneNumber?.trim() || "",

  dateOfBirth: formData.dateOfBirth, // 'YYYY-MM-DD'

  // Hometown → legacy fields
  hometownCity: hometownSel.location.city,
  hometownState: hometownSel.location.state || "",
  hometownCountry: hometownSel.location.country,
  hometown: safeJoinLocation(hometownSel.location),
  location: safeJoinLocation(hometownSel.location),

  // Destination → legacy fields (if traveling)
  currentTripDestinationCity: destSel.location.city,
  currentTripDestinationState: destSel.location.state || "",
  currentTripDestinationCountry: destSel.location.country,
  currentTripReturnDate: formData.currentTripReturnDate,

  // Interests (top 30; ≥3)
  interests: formData.interests,

  // EXTRA (non-breaking) fields so you never lose scope:
  // Backend will ignore unknown keys unless you validate strictly.
  hometownScope: hometownSel.scope,           // "city" | "metro"
  hometownMetro: hometownSel.metro,           // { metroCode, metroName } if metro
  destinationScope: destSel.scope,            // "city" | "metro"
  destinationMetro: destSel.metro,            // { metroCode, metroName } if metro
};


If your server rejects unknown keys, keep these four in the client state and include them after registration when saving the user profile via a separate endpoint or a PATCH /users/:id/metadata.

5) Keep LA-metro behavior in searches & feeds

Since you’ve preserved scope, your app logic can expand “Los Angeles Metropolitan” to all supported LA cities when filtering/feeding:

// lib/geoExpand.ts
const LA_CBSA = "31180";
const LA_METRO_CITIES = new Set([
  "Los Angeles", "Santa Monica", "Beverly Hills", "West Hollywood",
  "Culver City", "Pasadena", "Glendale", "Burbank", "Long Beach",
  "Inglewood", "Torrance", "El Segundo", /* …your full curated list … */
]);

export function expandToCities(sel: LocationSelection): string[] {
  if (sel.scope === "metro" && sel.metro?.metroCode === LA_CBSA) {
    return Array.from(LA_METRO_CITIES);
  }
  if (sel.scope === "city" && sel.location.city) {
    return [sel.location.city];
  }
  return [];
}


Use expandToCities wherever you match users/events/deals so “Los Angeles Metropolitan” works exactly like before.

6) Special-case display (so UX stays familiar)

If scope === "metro", show the metro badge/name (e.g., Los Angeles–Long Beach–Anaheim, CA).

If scope === "city", show “City, State, Country”.

7) Migration note (if needed)

If you already stored some users with only the concatenated string:

When reading profiles, detect “Los Angeles Metropolitan” in the string and reconstruct { scope: "metro", metroCode: "31180" }. Keep a quick mapping table to backfill scope for LA.

This way:

Your backend keeps getting the exact fields it expects (no breakage).

Your app never loses the “metro vs city” intent—especially for Los Angeles Metropolitan.

Your search/match logic can still treat LA-metro as a cluster of cities.