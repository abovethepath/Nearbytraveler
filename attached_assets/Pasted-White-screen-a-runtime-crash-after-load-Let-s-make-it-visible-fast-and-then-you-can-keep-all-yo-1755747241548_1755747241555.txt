White screen = a runtime crash after load. Let‚Äôs make it visible, fast, and then you can keep all your mobile infra.

Below is a drop-in ‚Äúwhite-screen rescue kit‚Äù: it catches runtime errors in prod, shows a friendly error box with the stack, and removes the usual culprits (undefined components like GlobalHotfixes, lazy routes without Suspense, etc.). Then we do a clean prod build.

1) Add a crash catcher (ErrorBoundary)

client/src/ErrorBoundary.tsx

import React from "react";

type State = { hasError: boolean; error?: any };

export default class ErrorBoundary extends React.Component<
  { children: React.ReactNode },
  State
> {
  state: State = { hasError: false };

  static getDerivedStateFromError(error: any) {
    return { hasError: true, error };
  }

  componentDidCatch(error: any, info: any) {
    // Log to console and window for quick debugging
    console.error("[App Crash]", error, info);
    (window as any).__LAST_APP_ERROR__ = { error, info };
  }

  render() {
    if (this.state.hasError) {
      const msg =
        (this.state.error && (this.state.error.message || String(this.state.error))) ||
        "Unknown error";
      return (
        <div style={{
          fontFamily: "system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial",
          padding: "1rem",
          maxWidth: 900,
          margin: "2rem auto",
          border: "1px solid #eee",
          borderRadius: 12,
          background: "#fff"
        }}>
          <h2 style={{marginTop:0}}>Something went wrong.</h2>
          <p style={{color:"#555"}}>{msg}</p>
          <pre style={{whiteSpace:"pre-wrap", background:"#f7f7f7", padding:"0.75rem", borderRadius:8, overflow:"auto"}}>
            {this.state.error?.stack || ""}
          </pre>
          <p style={{fontSize:12, color:"#999"}}>
            Open DevTools ‚Üí Console for full details. The last error is also at <code>window.__LAST_APP_ERROR__</code>.
          </p>
        </div>
      );
    }
    return this.props.children;
  }
}

2) Provide a safe fallback for GlobalHotfixes (no-op)

If your App.tsx referenced GlobalHotfixes (you saw the ‚Äúnot defined‚Äù error), add a tiny noop so prod never dies if it‚Äôs missing.

client/src/GlobalHotfixes.tsx

import React from "react";

// Shows your confirmation banner and applies CSS/order fixes safely.
// Keep it minimal to avoid crashes.
export default function GlobalHotfixes() {
  React.useEffect(() => {
    console.log("‚úÖ CRITICAL MOBILE LAYOUT v6-20250705 - SITE-WIDE FIXES DEPLOYED");
  }, []);
  return null;
}


Make sure App.tsx imports it:

import GlobalHotfixes from "@/GlobalHotfixes";

3) Harden your entry (main.tsx) so it can‚Äôt crash silently

client/src/main.tsx

import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";
import ErrorBoundary from "./ErrorBoundary";

const rootEl = document.getElementById("root");
if (!rootEl) {
  const el = document.createElement("div");
  el.id = "root";
  document.body.appendChild(el);
}

ReactDOM.createRoot(document.getElementById("root")!).render(
  // Remove StrictMode during prod debugging to avoid double-invoke confusion
  <ErrorBoundary>
    <App />
  </ErrorBoundary>
);

4) Wrap risky/lazy parts of App with Suspense + minimal shell

In client/src/App.tsx, ensure you have:

import React, { Suspense } from "react";
import GlobalHotfixes from "@/GlobalHotfixes";
import AppShell from "@/ui/AppShell"; // your wrapper
// import your router/lazy views...

export default function App() {
  return (
    <AppShell>
      <GlobalHotfixes />
      <Suspense fallback={<div style={{padding:16}}>Loading‚Ä¶</div>}>
        {/* your Router / main layout goes here */}
      </Suspense>
    </AppShell>
  );
}


This prevents a lazy route from crashing the entire page with a blank screen.

5) Build properly for prod (with sourcemaps)

You built with --mode development earlier; let‚Äôs do a clean production build with maps so the boundary shows helpful stacks.

# from repo root
pkill -f node || true
rm -rf dist client/node_modules/.vite .vite .replcache 2>/dev/null || true

# install if needed
# npm i

# clean prod build with sourcemaps
cd client
npx vite build --mode production --sourcemap
cd ..

# serve prod
NODE_ENV=production node server/index.prod.js


Open the app. If something still blows up, you‚Äôll see the ErrorBoundary UI instead of a white screen, plus the exact stack in the console.

6) If it‚Äôs STILL white: run the 30-second smoke test (isolates server vs app)

Temporarily replace App with a trivial component to prove the server/assets are fine:

client/src/App.tsx (temporarily)

export default function App() {
  return <div style={{padding:20, fontFamily:"sans-serif"}}>‚úÖ App shell renders</div>;
}


Rebuild + run:

cd client && npx vite build --mode production && cd ..
NODE_ENV=production node server/index.prod.js


If you now see ‚Äú‚úÖ App shell renders‚Äù ‚Üí server/build are fine; the crash is inside your real App/routes. Put back the real App and use the boundary stack to fix the exact component.

If you still see white ‚Üí it‚Äôs a serving path issue. In that case, ensure your prod server has SPA fallback (you likely already do), e.g.:

server/index.prod.js (snippet)

import path from "path";
import express from "express";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const dist = path.resolve(__dirname, "../dist/public");

app.use(express.static(dist, { maxAge: "0" }));
app.get("*", (_req, res) => res.sendFile(path.join(dist, "index.html")));

const PORT = process.env.PORT || 5000;
app.listen(PORT, "0.0.0.0", () => {
  console.log(`üöÄ Server successfully started on http://0.0.0.0:${PORT}`);
});

Likeliest culprits this will expose (and how to fix fast)

Undefined import (e.g., GlobalHotfixes) ‚Üí the noop fixes it permanently.

Accessing window/document during module init ‚Üí move to useEffect.

Lazy route without <Suspense> ‚Üí fixed above.

Env vars (import.meta.env.VITE_*) undefined in prod ‚Üí add defaults or guard, e.g. const api = import.meta.env.VITE_API_URL ?? "/api";

Bad Vite alias in prod ‚Üí we handled dev via dev-oneport, but prod reads vite.config.ts. If alias is missing there and you can‚Äôt edit it, switch imports to relative (@/foo ‚Üí ../../foo) in the few failing files (boundary stack will tell you which).

CSS import order crash (rare) ‚Üí keep index.css imports first, and avoid side-effect CSS in random leaf modules.

After you see the boundary error box

Paste the top 10 lines of the error stack it shows, and I‚Äôll give you the exact code fix (file + line). The boundary ensures we‚Äôre no longer guessing at a blank screen‚Äîwe‚Äôll have the precise failing component.